pub fn math(text: &str) -> i64 {
    println!("{}", text);
    let number_words: Vec<(&str, i64)> = vec![
        ("ноль", 0),
        ("один", 1),
        ("одна", 1),
        ("две", 2),
        ("два", 2),
        ("три", 3),
        ("четыре", 4),
        ("пять", 5),
        ("шесть", 6),
        ("семь", 7),
        ("восемь", 8),
        ("девять", 9),
        ("десять", 10),
        ("одиннадцать", 11),
        ("двенадцать", 12),
        ("тринадцать", 13),
        ("четырнадцать", 14),
        ("пятнадцать", 15),
        ("шестнадцать", 16),
        ("семнадцать", 17),
        ("восемнадцать", 18),
        ("девятнадцать", 19),
        ("двадцать", 20),
        ("тридцать", 30),
        ("сорок", 40),
        ("пятьдесят", 50),
        ("шестьдесят", 60),
        ("семьдесят", 70),
        ("восемьдесят", 80),
        ("девяносто", 90),
        ("сто", 100),
        ("двести", 200),
        ("триста", 300),
        ("четыреста", 400),
        ("пятьсот", 500),
        ("шестьсот", 600),
        ("семьсот", 700),
        ("восемьсот", 800),
        ("девятьсот", 900),
        ("тысяча", 1000),
        ("тысячи", 1000),
        ("тысяч", 1000),
        ("миллион", 1_000_000),
        ("миллиона", 1_000_000),
        ("миллионов", 1_000_000),
    ];

    let mut numbers: Vec<i64> = Vec::new();
    let mut operations: Vec<&str> = Vec::new();
    let mut current_number = 0;

    // Разбиваем текст на слова и обрабатываем их
    for word in text.split_whitespace() {
        if word == "плюс" || word == "минус" || word == "умножить" || word == "разделить" {
            operations.push(word);
            numbers.push(current_number);
            current_number = 0;
        } else if let Some(&(_, value)) = number_words.iter().find(|&&(w, _)| w == word) {
            if value == 1000 || value == 1_000_000 {
                current_number *= value;
            } else {
                current_number += value;
            }
        }
    }
    numbers.push(current_number);

    // Вычисляем выражение с учетом приоритета операций
    let mut result = numbers[0];
    let mut i = 0;

    // Сначала обрабатываем умножение и деление
    while i < operations.len() {
        match operations[i] {
            "умножить" => {
                result *= numbers[i + 1];
            }
            "разделить" => {
                result /= numbers[i + 1];
            }
            _ => {}
        }
        i += 1;
    }

    // Затем обрабатываем сложение и вычитание
    i = 0;
    while i < operations.len() {
        match operations[i] {
            "плюс" => {
                result += numbers[i + 1];
            }
            "минус" => {
                result -= numbers[i + 1];
            }
            _ => {}
        }
        i += 1;
    }

    result
}